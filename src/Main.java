import java.util.*;

public class Main {

    // programmers level 3 - 멀리 뛰기
    // 1 - 1
    // 2 - 2
    // 3 - 3
    // 4 - 5
    // 5 - 8?
    // 이라는 규칙이 보여서 ( 전전 + 전 = 현재 ) 라는 공식에 맞춰질 것 같았다.
    // n = 5 까지일때까지밖에 못 구해서 사실 확신을 가지기는 힘들었다.
    // 그 후 동적계획법을 실행하는 것은 어렵지 않았다.
    // 다만 한 가지 케이스에서 계속 실패 혹은 런타임에러가 났는데 코드가 간결하다 보니
    // 오히려 어디서 오류가 나는지 알아내는 게 상당히 어려웠다.
    // 근데 계속 보다보니 n개 만큼 dp 배열의 크기를 구했는데 규칙에 맞추기 위해서
    // dp[0]와 dp[1]의 값을 미리 넣었기 때문에 오류가 났다...
    // dp 자체의 크기가 1인 경우도 있는데 dp[1]의 값을 넣으려 하니 문제가 발생하였다.

    public static void main(String[] args) {

        int n = 2; // n은 2000이하 정수

        int[] dp = new int[n];
//        if(n==1) return 1;

        dp[0] = 1;
        dp[1] = 2;


        for(int i=2;i<n;i++){
            dp[i] = (dp[i-1] + dp[i-2]) % 1234567;
        }

//        return dp[n-1];

    }
}