import java.awt.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    // java 1904 01타일

//    어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다.
//    결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.
//
//    그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다.
//    예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.)
//    또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.
//
//    우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.

    // 문제는 간단하다. 00과 1이라는 수를 가지고 주어지는 N의 길이를 만드는 경우의 수를 구하는 것이다.
    // 처음에 규칙을 찾기 위해서 6까지 모든 경우의 수를 직접 구해보았다. 그렇게 보니 피보나치 수열과 같은 점화식을 가지는 것으로 보여서
    // dp[i] = dp[i-1] + dp[i-2]로 처리했는데 오답이 나와서 수가 커지면 규칙이 깨지는 건가 싶어서 고민을 좀 더 했다.
    // 생각했던 건 i가 짝수면 00만으로 이루어지는 경우의 수가 존재하고 홀수일 때는 불가능하기 때문에 처음에는 홀수 짝수를 나눠서
    // 문제를 구해야하나 하는 생각을 했었는데 생각해보니 짝수 홀수를 나누는게 의미가 없는게 dp[i]를 구하는 점화식을 따로 구하는 게 아니기 때문에
    // 짝수 홀수를 나누더라도 dp[i]를 구할 수 없다고 생각했다.
    // 또한 피보나치 수열로 i <= 1000000 까지인데 dp[i-1] + dp[i-2]면 int 범위를 벗어나는 것이 아닐까 싶어서 dp를 long으로 해야하나
    // 싶어서 문제를 다시 살펴봤더니 그렇지 않아도 특정 수로 나눈 나머지를 구했어야 하는 문제였다 ㅠㅠ ( 문제를 이걸 놓치고.... 시간을....)

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        int[] dp = new int[10000001];

        dp[1] = 1; // 1
        dp[2] = 2; // 00 11
        dp[3] = 3; // 111 001 100
        dp[4] = 5; // 0011 0000 1001 1100 1111
        dp[5] = 8; // 11111 00111 11100 10011 11001 10000 00100 00001
        dp[6] = 13; // 111111 000000 110000 000011 100100 100001 001001 001100
                   // 001111 100111 110011 111001 111100

        for(int i=6;i<=1000000;i++){
            dp[i] = ( dp[i-1] + dp[i-2] ) % 15746;
        }

        System.out.println(dp[N]);

    }
}