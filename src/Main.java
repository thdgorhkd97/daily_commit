import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

//    인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.
//
//    사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.
//
//    줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.
//
//    줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.

    // 기다리는 시간을 포함해서 모든 사람이 업무를 마치는 시간의 합이 최소가 되어야 하기 때문에
    // 비슷한 로직의 다른 문제를 생각했을 때 실행시간이 짧은 사람부터 업무를 처리해 나가면서
    // 대기시간을 최소로 만드는게 정답이라고 생각했다.

    // 처음에는 모든 사람들의 실행시간을 모두 더하고 for문의 인덱스에 따라 대기시간을 더하는 방식으로 했다.
    // 가장 첫번째는 마지막 사람까지모두 기다리기 때문에 N배 더하고 그 다음은 N-1배 이런 식으로
    // 더해나갔는데 굳이 이렇게 로직을 길게 짤 필요가 없을 것 같다는 생각이 들었다.
    // 그냥 for문을 돌면서 한번에 마치 동적계획법처럼 앞 사람의 실행시간을 뒷사람의 실행시간에 더해버리면
    // 앞사람의 실행시간만큼 뒷사람이 대기하는 것이기 때문에 한번에 처리가 가능하다고 생각했다.

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());

        int[] time = new int[N];

        String str = br.readLine();

        StringTokenizer stk = new StringTokenizer(str," ");

        for(int i=0;i<N;i++){
            time[i] = Integer.parseInt(stk.nextToken());
        }

        Arrays.sort(time); // 업무 처리시간을 정렬
        // 짧은 시간을 가지는 사람부터 처리하면 뒤에 있는 사람들도 대기 시간이 최소화

        int minTime = 0;

        for(int i=0;i<N-1;i++){
            minTime += time[i]; // 실행시간을 더하고
            time[i+1] += time[i]; // 앞 사람의 실행시간을 더해서 뒷사람의 대기시간을 만든다.
            //  즉 뒷사람은 앞사람들의 실행시간 + 본인의 실행시간
        }

        minTime += time[time.length-1]; // 가장 마지막 사람의 대기시간 + 실행시간간

       System.out.println(minTime);



    }
}